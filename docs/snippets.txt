https://martinheinz.dev/blog/32
class Person:
    def __init__(self, **kwargs):
        self.__dict__.update(**kwargs)

class Person:
    def __init__(self, **kwargs):
        vars(self).update(**kwargs)  # Alternatively use `vars()`
The snippet above demonstrates usage of self.__dict__ which is a dictionary which stores all the attributes of class (unless __slots__ is declared)



https://stackoverflow.com/questions/5268404/what-is-the-fastest-way-to-check-if-a-class-has-a-function-defined
invert_op = getattr(self, "invert_op", None)
if callable(invert_op):
    invert_op(self.path.parent_op)



https://stackoverflow.com/questions/5910703/how-to-get-all-methods-of-a-python-class-with-given-decorator




#sys.path.append(os.path.abspath('src'))
#sys.path.append(os.path.abspath('adt'))
#sys.path.append(os.path.abspath('core'))
#sys.path.append(os.path.abspath('patterns'))
#sys.path.append(os.path.abspath('algorithms'))


import importlib
 modnames = ["os", "sys", "math"]
 for lib in modnames:
     globals()[lib] = importlib.import_module(lib)



# How to merge two dictionaries
# in Python 3.5+
>>> x = {'a': 1, 'b': 2}
>>> y = {'b': 3, 'c': 4}
>>> z = {**x, **y}
>>> z
{'c': 4, 'a': 1, 'b': 3}



# Different ways to test multiple
# flags at once in Python
x, y, z = 0, 1, 0

if x == 1 or y == 1 or z == 1:
    print('passed')

if 1 in (x, y, z):
    print('passed')

# These only test for truthiness:
if x or y or z:
    print('passed')

if any((x, y, z)):
    print('passed')





    @staticmethod
    def collect_predecessors(vertex, graph):
        """
        """
        assert vertex is not None, "Invalid argument 'vertex'"
        assert vertex.id in graph.vertices, f"Missing vertex: {vertex}"
        result = list()
        if graph.digraph:
            pass
        else:
            edges = graph.get_edges(vertex)
            for edge in edges:
                vertex_u = edge.endpoints[0]
                vertex_v = edge.endpoints[1]
                if vertex == vertex_v:  # incoming edge
                    result.append(vertex_u)
        return result




# How to sort a Python dict by value
# (== get a representation sorted by value)

>>> xs = {'a': 4, 'b': 3, 'c': 2, 'd': 1}

>>> sorted(xs.items(), key=lambda x: x[1])
[('d', 1), ('c', 2), ('b', 3), ('a', 4)]

# Or:

>>> import operator
>>> sorted(xs.items(), key=operator.itemgetter(1))
[('d', 1), ('c', 2), ('b', 3), ('a', 4)]




        collected_vertices = list()
        dfs_visitor = DfsVisitor(graph)
        for vertex in graph.vertices.values():
            if (vertex.flags & Flags.VISITED) != Flags.VISITED:
                v = dfs_visitor.visit(vertex, callback=lambda v: collected_vertices.append(v))
                collected_vertices.append(next(v))
        assert collected_vertices == [v1, v2, v3]





# The get() method on dicts
# and its "default" argument
name_for_userid = {
    382: "Alice",
    590: "Bob",
    951: "Dilbert",
}

def greeting(userid):
    return "Hi %s!" % name_for_userid.get(userid, "there")

>>> greeting(382)
"Hi Alice!"
>>> greeting(333333)
"Hi there!"





            for vertex in graph.vertices.values():
                if (vertex.flags & Flags.VISITED) != Flags.VISITED:
                    for v in GraphAlgorithms.dfs(vertex):
                        collected_vertices.append(v)
            assert len(collected_vertices) == len(vertices)




reverse list
[result[k] for k in range(len(result)-1, -1, -1)]




        for i in range(len(self._vertices)):
            result.append([0 for i in range(len(self._vertices))])
        for edge in self._edges.values():
            result[edge.endpoints[0].id][edge.endpoints[1].id] = edge.value if edge.value else 1



https://realpython.com/primer-on-python-decorators/
import functools

def debug(func):
    """Print the function signature and return value"""
    @functools.wraps(func)
    def wrapper_debug(*args, **kwargs):
        args_repr = [repr(a) for a in args]                      # 1
        kwargs_repr = [f"{k}={v!r}" for k, v in kwargs.items()]  # 2
        signature = ", ".join(args_repr + kwargs_repr)           # 3
        print(f"Calling {func.__name__}({signature})")
        value = func(*args, **kwargs)
        print(f"{func.__name__!r} returned {value!r}")           # 4
        return value
    return wrapper_debug

import math
from decorators import debug

# Apply a decorator to a standard library function
math.factorial = debug(math.factorial)

def approximate_e(terms=18):
    return sum(1 / math.factorial(n) for n in range(terms))






        def dfs(node):
            stack.append(node)
            nodes.append(node)
            for kid in node.kids:
                dfs(kid)
                nodes.append(node)
            stack.pop()

        dfs(tree)




